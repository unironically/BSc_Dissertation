package main;

import automaton.base.State;
import automaton.dfa.DFA;
import automaton.dfa.DFAState;
import automaton.nfa.NFA;

import java.util.ArrayList;

/**
 * Class allowing us to construct deterministic finite-state automaton using subset construction.
 */
public class DFAConstructor {

    /**
     * The non-deterministic finite-state automaton to construct a DFA from.
     */
    private NFA nfa;

    /**
     * The output DFA generated by subset construction.
     */
    private DFA dfa;

    /**
     * ArrayList of DFA states we add to the new DFA object after construction.
     */
    private ArrayList<DFAState> statesList;

    /**
     * Array of characters supported by the NFA and DFa.
     */
    private char[] alphabet;

    /**
     * Constructor for DFAConstructor objects.
     * @param nfa The NFA to construct the new DFA from.
     * @param alphabet The array of characters supported by the NFA.
     */
    public DFAConstructor(NFA nfa, char[] alphabet) {
        this.nfa = nfa;
        this.statesList = new ArrayList<>();
        this.alphabet = alphabet;
    }

    /**
     * Method to begin construction of the new DFA object and label the states when finished.
     * @return The new DFA object attained using subset construction.
     */
    public DFA construct() {
        ArrayList<State> startClosure = nfa.getStart().epsilonClosure();
        dfa = new DFA(alphabet);
        DFAState startState = dfa.newState(startClosure, startClosure.contains(nfa.getFinish()));
        dfa.setStart(startState);
        statesList.add(startState);
        subsetConstruct();
        dfa.relabel();
        return dfa;
    }

    /**
     * Method to create the states of the new DFA using subset construction.
     */
    private void subsetConstruct() {
        DFAState currentState;
        while ((currentState = nextUnMarkedState()) != null) {
            currentState.markHandled();
            for (char c: alphabet) {
                ArrayList<State> fullClosure = getFullClosure(currentState, c);
                if (fullClosure.size() <= 0) continue;
                DFAState U = dfa.newState(fullClosure, fullClosure.contains(nfa.getAcceptingStates().get(0)));
                DFAState old = getExisting(U);
                if (old == null) {
                    currentState.addTransition(c, U);
                    statesList.add(U);
                } else {
                    currentState.addTransition(c, old);
                    dfa.removeState(U);
                }
            }
        }
    }

    /**
     * Method to get the character closure of a current state, and the epsilon closure of the states within said
     * character closure. This list of states is then encapsulated within a new DFA state.
     * @param currentState The current DFAState object to transition from.
     * @param transitionChar The character to transition from the current state on.
     * @return ArrayList of states we can reach with the transition character from the current DFA state.
     */
    private ArrayList<State> getFullClosure(DFAState currentState, char transitionChar) {
        ArrayList<State> characterClosures = new ArrayList<>();
        ArrayList<State> epsilonClosures = new ArrayList<>();
        for (State s: currentState.getNFASubStates()) {
            characterClosures = mergeClosures(characterClosures, s.characterClosure(transitionChar));
        }
        for (State s: characterClosures) {
            ArrayList<State> epsClosures = s.epsilonClosure();
            if (epsClosures == null) continue;
            epsilonClosures = mergeClosures(epsilonClosures, s.epsilonClosure());
        }
        return epsilonClosures;
    }

    /**
     * Method to get the next unmarked state for use in subset construction.
     * @return The DFAState which has not yet been handled.
     */
    private DFAState nextUnMarkedState() {
        for (DFAState state: statesList) {
            if (!state.isHandled()) return state;
        }
        return null;
    }

    /**
     * Method to determine whether a DFAState object with a given set of NFA sub-states already exists within the new DFA.
     * @param state The DFAState object to test the existence of.
     * @return The equivalent existing DFA state if it exists, null otherwise.
     */
    private DFAState getExisting(DFAState state) {
        for (DFAState s: statesList) {
            if (s.equals(state)) return s;
        }
        return null;
    }

    /**
     * Method to merge the epsilon and character closures of a DFA state, not allowing duplicate NFA sub-states.
     * @param left The left ArrayList of states to merge.
     * @param right The right ArrayList of states to merge.
     * @return The merged ArrayList of NFA states.
     */
    private ArrayList<State> mergeClosures(ArrayList<State> left, ArrayList<State> right) {
        for (State state: right) {
            if (!left.contains(state)) left.add(state);
        }
        return left;
    }

}
