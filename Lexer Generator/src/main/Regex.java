package main;

import exception.InvalidExpressionException;

import java.util.ArrayList;

/**
 * Class allowing us to take in input regular expression and expand it to the syntax recognised by
 * Thompson's construction.
 */
public class Regex {

    /**
     * Array of characters within the input expression.
     */
    private char[] expression;

    /**
     * ArrayList representing the alphabet of the expression we can add characters to.
     */
    private ArrayList<Character> alphabet;

    /**
     * StringBuilder object representing the new expanded regular expression.
     */
    private StringBuilder newRegex;

    /**
     * String of the last expression clause added, used by closures.
     */
    private String lastAdded;

    /**
     * Constructor for Regex objects.
     * @param originalFormat Original regular expression input to convert to an expanded expression.
     * @throws InvalidExpressionException Thrown when an input regular expression is invalid.
     */
    public Regex(String originalFormat) throws InvalidExpressionException {
        expression = originalFormat.toCharArray();
        alphabet = new ArrayList<>();
        newRegex = new StringBuilder();
        lastAdded = "";
        construct();
    }

    /**
     * Method to begin constructing the expanded regular expression from the input expression.
     * @throws InvalidExpressionException Thrown when an input regular expression is invalid.
     */
    private void construct() throws InvalidExpressionException {
        boolean isEscaped = false;
        for (int i = 0; i < expression.length; i++) {
            if (isEscaped){
                handleEscaped(expression[i]);
            } else {
                switch (expression[i]) {
                    case '(':
                        i = handleParentheses(expression, i);
                        break;
                    case '{':
                        i = handleQuantifier(expression, i);
                        break;
                    case '[':
                        i = handleSquareBrackets(expression, i);
                        break;
                    case '?': case '+':
                        handleOptionalOrPositive(getLastClauseAdded(), expression[i]);
                        break;
                    case '*': case '|' :
                        newRegex.append(expression[i]); lastAdded = Character.toString(expression[i]);
                        break;
                    case '\\':
                        isEscaped = true;
                        continue;
                    default:
                        addChar(expression[i], false);
                        addToAlphabet(expression[i]);
                }
            }
            isEscaped = false;
        }
    }

    /**
     * Method to handle a chaeacter which is escaped using '\' in the original expression.
     * @param inputChar The character which has been escaped.
     */
    private void handleEscaped(char inputChar) {
        if (isExpansionSyntax(inputChar)) {
            addChar(inputChar, true);
            addToAlphabet(inputChar);
        } else {
            String subexpression = handleBackslashExpression(inputChar);
            newRegex.append(subexpression);
            lastAdded = subexpression;
        }
    }

    /**
     * Method to determine whether an input character is a member of the list of syntax characters used by expressions
     * supported by Thompson's construction.
     * @param inputChar The input character to test for.
     * @return Boolean indicating whether the input char belongs to the syntax characters.
     */
    private boolean isExpansionSyntax(char inputChar) {
        return isOperator(inputChar) || inputChar == '(' || inputChar == ')' || inputChar == '\\';
    }

    /**
     * Method to determine whether an input character is an operator of the expressions supported by Thompson's construction.
     * @param inputChar The input character to test for.
     * @return Boolean indicating whether the input char is an operator.
     */
    private boolean isOperator(char inputChar) {
        return inputChar == '*' || inputChar == '|';
    }

    /**
     * Method to handle an escaped single character, which may indicate the shorthand version of the regular expression
     * for any word or any digit.
     * @param inputChar The input character to handle.
     * @return The string generated by the escaped character.
     */
    private String handleBackslashExpression(char inputChar) {
        StringBuilder builder = new StringBuilder();
        boolean isIdentifier = true;
        switch (inputChar) {
            case 'w':
                builder.append(alternateAllBetween('A', 'Z') + '|');
                builder.append(alternateAllBetween('a', 'z') + '|');
                builder.append(alternateAllBetween('0', '9') + '|');
                builder.append('_');
                break;
            case 'd':
                builder.append(alternateAllBetween('0', '9'));
                break;
            default:
                addToAlphabet(inputChar);
                builder.append(inputChar);
                isIdentifier = false;
        }
        String toAdd = (isIdentifier) ? '(' + builder.toString() + ')' : builder.toString();
        return toAdd;
    }

    /**
     * Method to get all of the ascii characters between two existing characters, used within regular expression range
     * ([a-c] -> (a|b|c)).
     * @param start The first character in the sequence.
     * @param end The last character in the sequence.
     * @return The expanded representation of the range expression.
     */
    private String alternateAllBetween(char start, char end) {
        StringBuilder builder = new StringBuilder();
        for (int i = start; i <= end; i++) {
            builder.append((char) i);
            addToAlphabet((char) i);
            if (i < end) builder.append('|');
        }
        return builder.toString();
    }

    /**
     * Method to handle either the positive '+' or optional '?' closure of the last clause added to the new expression.
     * @param toAdd The string to complete the closure for.
     * @param operator The closure type, optional or positive.
     */
    private void handleOptionalOrPositive(String toAdd, char operator) {
        StringBuilder builder = new StringBuilder();
        builder.append('(');
        if (operator == '?') builder.append("Îµ|");
        else if (operator == '+') toAdd += toAdd + "*";
        builder.append(toAdd);
        builder.append(')');
        newRegex.append(builder);
    }

    /**
     * Method to add a new character to the expanded expression.
     * @param inputChar The new character to add to the expression.
     * @param isEscaped Boolean indicating whether the character is escaped or not.
     */
    private void addChar(char inputChar, boolean isEscaped) {
        String prefix = isEscaped ? "\\" : "";
        newRegex.append(prefix + inputChar);
        lastAdded = Character.toString(inputChar);
    }

    /**
     * Method to handle the sub-expression contained within a set of parentheses.
     * @param subexpression The sub-expression array to handle containing the parentheses.
     * @param firstBracketIndex The index of the first opening parenthesis of the expression.
     * @return The int index of the closing parenthesis.
     * @throws InvalidExpressionException Thrown when an input regular expression is invalid.
     */
    private int handleParentheses(char[] subexpression, int firstBracketIndex) throws InvalidExpressionException {
        StringBuilder builder = new StringBuilder();
        int closingBracketIndex = getLastBracket(subexpression, firstBracketIndex, '(', ')');
        if (closingBracketIndex <= 0) throw new InvalidExpressionException("Unbalanced parentheses for input Regex.");
        boolean isEscaped = false;
        for (int i = firstBracketIndex; i <= closingBracketIndex; i++) {
            if (isEscaped || !isExpansionSyntax(subexpression[i])) {
                addToAlphabet(subexpression[i]);
            } else if (subexpression[i] == '\\') {
                isEscaped = true;
                continue;
            }
            String prefix = (isEscaped) ? "\\" : "";
            builder.append(prefix + subexpression[i]);
            isEscaped = false;
        }
        newRegex.append(builder);
        lastAdded = builder.toString();
        return closingBracketIndex;
    }

    /**
     * Method to handle quantifier expressions, e.g. a{2,} to support 'a' between two and infinity times.
     * @param subexpression The sub-expression of characters containing the quantifier.
     * @param firstBracketIndex The index of the opening brace of the quantifier.
     * @return The int index of the closing brace.
     * @throws InvalidExpressionException Thrown when an input regular expression is invalid.
     */
    private int handleQuantifier(char[] subexpression, int firstBracketIndex) throws InvalidExpressionException {
        int closingBracketIndex = getLastBracket(subexpression, firstBracketIndex, '{', '}');
        if (closingBracketIndex == -1)
            throw new InvalidExpressionException("Unbalanced quantifier brackets for input Regex.");
        String toRepeat = getLastClauseAdded();
        Integer[] range = splitQuantifier(subexpression, firstBracketIndex, closingBracketIndex);
        buildFromQuantifier(range, toRepeat);
        return closingBracketIndex;
    }

    /**
     * Method to multiply a sub-expression based on the existence of a quantifier within the expression.
     * @param quantifierValues The range of numbers to repeat, determined by the quantifier.
     * @param toRepeat The string expression to repeat.
     */
    private void buildFromQuantifier(Integer[] quantifierValues, String toRepeat) {
        StringBuilder builder = new StringBuilder();
        builder.append("(");
        if (quantifierValues[1] != null) {
            for (int i = quantifierValues[0]; i <= quantifierValues[1]; i++) {
                builder.append(repeatString(toRepeat, i));
                if (i != quantifierValues[1]) builder.append("|");
            }
        } else {
            builder.append(repeatString(toRepeat, quantifierValues[0]));
            builder.append(toRepeat + "*");
        }
        builder.append(")");
        newRegex.append(builder);
    }

    /**
     * Method to repeat a given expression when using a quantifier.
     * @param toRepeat The string expression to repeat.
     * @param times The number of times to repeat the expression.
     * @return String object containing the repeated expression.
     */
    private String repeatString(String toRepeat, int times) {
        StringBuilder builder = new StringBuilder();
        for (int i = 0; i < times; i++) {
            builder.append(toRepeat);
        }
        return builder.toString();
    }

    /**
     * Method to get the last sub-expression added to the new regular expression, which we use for closures.
     * @return The last sub-expression added.
     * @throws InvalidExpressionException Thrown when an input regular expression is invalid.
     */
    private String getLastClauseAdded() throws InvalidExpressionException {
        if (isOperator(lastAdded.charAt(lastAdded.length()-1)))
            throw new InvalidExpressionException("Invalid quantifier target.");
        int existingRegexLength = newRegex.length();
        for (int i = 1; i <= lastAdded.length(); i++) {
            newRegex.deleteCharAt(existingRegexLength-i);
        }
        return lastAdded;
    }

    /**
     * Method to split a quantifier into its two numbers which represent the quantifier range.
     * @param subexpression The character sub-expression which represents the quantifier.
     * @param firstBracketIndex The index of the opening brace of the quantifier.
     * @param closingBracketIndex The index of the closing brace of the quantifier.
     * @return Array of integers representing the range of the quantifier.
     * @throws InvalidExpressionException Thrown when an input regular expression is invalid.
     */
    private Integer[] splitQuantifier(char[] subexpression, int firstBracketIndex, int closingBracketIndex)
            throws InvalidExpressionException {
        Integer firstNum = 0, secondNum = null;
        boolean reachedSplit = false;
        for (int i = firstBracketIndex + 1; i < closingBracketIndex; i++) {
            if (subexpression[i] == ',') {
                reachedSplit = !reachedSplit;
                if (!reachedSplit) throw new InvalidExpressionException("Too many split characters in quantifier.");
                else if (i == closingBracketIndex - 1) break;
                secondNum = 0;
            } else if (Character.isDigit(subexpression[i])) {
                if (!reachedSplit) {
                    firstNum = firstNum * 10 + Character.getNumericValue(subexpression[i]);
                    continue;
                }
                secondNum = secondNum * 10 + Character.getNumericValue(subexpression[i]);
            } else {
                throw new InvalidExpressionException("Invalid character for quantifier.");
            }
        }
        if (firstNum <= 0 || (secondNum != null && secondNum < firstNum))
            throw new InvalidExpressionException("Invalid quantifier values.");
        else if (!reachedSplit) secondNum = firstNum;
        return new Integer[] {firstNum, secondNum};
    }

    /**
     * Method to handle a 'range' expression denoted by a set of square brackets.
     * @param subexpression The sub-expression containing the range syntax.
     * @param firstBracketIndex The index of the opening square bracket.
     * @return The index of the closing square bracket.
     * @throws InvalidExpressionException Thrown when an input regular expression is invalid.
     */
    private int handleSquareBrackets(char[] subexpression, int firstBracketIndex) throws InvalidExpressionException {
        ArrayList<Character> charsInBrackets = new ArrayList<>();
        int closingBracket = getLastBracket(subexpression, firstBracketIndex, '[', ']');
        if (closingBracket == -1)
            throw new InvalidExpressionException("Unbalanced square brackets for input Regex.");
        char lastAddedChar = 0;
        boolean inRange = false;
        boolean isEscaped = false;
        for (int i = firstBracketIndex + 1; i < closingBracket; i++) {
            char currentChar = subexpression[i];
            if (currentChar == '-' && !isEscaped && i > firstBracketIndex + 1 && i < closingBracket - 1) {
                inRange = true;
            } else if (currentChar == '\\') {
                if (i >= closingBracket - 1) throw new InvalidExpressionException("Unbalanced square brackets.");
                isEscaped = true;
            } else if (inRange) {
                if (lastAddedChar > currentChar) throw new InvalidExpressionException("Quantifier range invalid.");
                for (int j = lastAddedChar+1; j <= currentChar; j++) charsInBrackets.add((char) j);
                inRange = false;
            } else {
                inRange = false;
                isEscaped = false;
                charsInBrackets.add(currentChar);
                lastAddedChar = currentChar;
            }
        }
        addExpressionForRange(charsInBrackets);
        for (Character c: charsInBrackets) addToAlphabet(c);
        return closingBracket;
    }

    /**
     * Method to add all of the characters within a 'range' expression to the new expanded expression.
     * @param range The characters to alternate over within the new expression.
     */
    private void addExpressionForRange(ArrayList<Character> range) {
        StringBuilder builder = new StringBuilder();
        builder.append("(");
        for (int i = 0; i < range.size(); i++) {
            String prefix = (isExpansionSyntax(range.get(i))) ? "\\" : "";
            builder.append(prefix + range.get(i));
            if (i < range.size()-1) builder.append("|");
        }
        builder.append(")");
        newRegex.append(builder);
        lastAdded = builder.toString();
    }

    /**
     * Method to get the closing bracket of a given expression based on the input bracket types.
     * @param subexpression The sub-expression to search for the closing bracket within.
     * @param firstBracketIndex The index of the opening bracket.
     * @param bracketOpen The character type of the opening bracket.
     * @param bracketClose The character corresponding to the closing bracket of the expression.
     * @return The index of the closing bracket.
     */
    private int getLastBracket(char[] subexpression, int firstBracketIndex, char bracketOpen, char bracketClose) {
        int bracketCount = 0;
        boolean isEscaped = false;
        for (int i = firstBracketIndex; i < subexpression.length; i++) {
            if (subexpression[i] == bracketOpen && !isEscaped) {
                bracketCount++;
            } else if (subexpression[i] == bracketClose && !isEscaped) {
                bracketCount--;
                if (bracketCount == 0) return i;
            } else if (subexpression[i] == '\\') {  // '\'
                isEscaped = true;
            } else {
                isEscaped = false;
            }
        }
        return -1;
    }

    /**
     * Method to get the alphabet of the new expanded expression as a character array from a list.
     * @return The character array of the alphabet.
     */
    public char[] getAlphabet() {
        char[] alphabetNew = new char[alphabet.size()];
        for (int i = 0; i < alphabetNew.length; i++) alphabetNew[i] = alphabet.get(i);
        return alphabetNew;
    }

    /**
     * Method to get the new expanded regular expression in syntax supported by Thompson's construction.
     * @return
     */
    public String getExpansion() {
        return newRegex.toString();
    }

    /**
     * Method to add a character to the alphabet if it doesn't already exist within the alphabet.
     * @param inputChar The character to add.
     */
    private void addToAlphabet(char inputChar) {
        if (!alphabet.contains(inputChar)) alphabet.add(inputChar);
    }

}
