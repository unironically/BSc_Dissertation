package main;

/**
 * Class for creating the stack code to be interpreted later by a post-order traverse of the reduced syntax tree
 * passed to the traverseTree method.
 */
public class Generator {

    /**
     * SymbolTable object which stores already initialised program variables which we can generate stack code for.
     */
    private SymbolTable symbolTable;

    /**
     * Constructor for creating new Generator objects.
     * @param symbolTable SymbolTable object encapsulating a map of already initialised program variables.
     */
    public Generator(SymbolTable symbolTable) {
        this.symbolTable = symbolTable;
    }

    /**
     * Method to take the root of a reduced syntax tree and begin the generation of the corresponding stack code.
     * @param root TreeNode of the root of the reduced input tree we generate stack code from.
     * @return String representing the stack code generated by a Generator object.
     */
    public String generateFromTree(TreeNode root) {
        StringBuilder builder = new StringBuilder();
        try {
            return traverseTree(root, builder);
        } catch (NoSuchFieldException e) {
            return null;
        }
    }

    /**
     * Method to post-order traverse the reduced syntax tree and handle the individual tokens found.
     * @param root TreeNode root of the reduced syntax tree.
     * @param builder StringBuilder to add the stack code to when tokens are handled individually.
     * @return String representing the generated stack code.
     * @throws NoSuchFieldException Thrown when a variable not yet initialised appears in an expression.
     */
    private String traverseTree(TreeNode root, StringBuilder builder) throws NoSuchFieldException {
        if (root == null) return null;
        String stackCommand = handleToken(root.getToken());
        if (stackCommand == null) throw new NoSuchFieldException();
        traverseTree(root.getLeft(), builder);
        traverseTree(root.getRight(), builder);
        builder.append(stackCommand + "\n");
        return builder.toString();
    }

    /**
     * Method to begin handling an individual TreeToken based on its type.
     * @param token TreeToken object to be converted to stack code.
     * @return String representing the stack code for a given TreeToken.
     */
    private String handleToken(TreeToken token) {
        if (token.getType() == TreeToken.TokenType.NUMBER) {
            return "PUSH " + token.toString() + ";";
        }
        return handleOperation(token);
    }

    /**
     * Method to handle TreeTokens which represent arithmetic operations.
     * @param token TreeToken object of an arithmetic operator.
     * @return String representing the stack code for the operator TreeToken.
     */
    private String handleOperation(TreeToken token) {
        TreeToken.TokenType currentType = token.getType();
        if (currentType == TreeToken.TokenType.IDENTIFIER) {
            return handleIdentifier(token.toString());
        }
        return currentType.toString() + ";";
    }

    /**
     * Method to handle TreeTokens which represent variables, generating stack code which pushes their values.
     * @param identifierName String name of the variable found within the tree.
     * @return String representing the stack code for the variable.
     */
    private String handleIdentifier(String identifierName) {
        Double storedVal = symbolTable.getIdentifierValue(identifierName);
        if (storedVal == null) {
            System.out.println("Error: no such identifier '" + identifierName + "'");
            return null;
        }
        return "PUSH " + storedVal + ";";
    }

}
